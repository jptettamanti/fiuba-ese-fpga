KCPSM3 Assembler log file for program 'prog_rom.psm'.
Generated by KCPSM3 version 1.20
Ken Chapman (Xilinx Ltd) 2004.

 Addr Code

 000                     ;Test del multiplicador
 000                     ;************************************
 000                     ; Nombres de los registros
 000                     ;************************************
 000                     NAMEREG s0, multiplicando
 000                     NAMEREG s1, multiplicador
 000                     NAMEREG s2, signo
 000                     NAMEREG s3, resultado_alto
 000                     NAMEREG s4, resultado_bajo
 000                     NAMEREG s5, semaforo_mult
 000                     NAMEREG s6, esperado_alto
 000                     NAMEREG s7, esperado_bajo
 000                     NAMEREG s8, esperado_ok
 000                     ;************************************
 000                     ; Direcciones de registros
 000                     ;************************************
 000                     ; Direcciones de los registros del multiplicador
 000                     CONSTANT n1, 01
 000                     CONSTANT n2, 02
 000                     CONSTANT sign, 03
 000                     CONSTANT rh, 04
 000                     CONSTANT rl, 05
 000                     CONSTANT led_sin_signo, 02
 000                     CONSTANT led_con_signo, 03
 000                     ;************************************
 000                     ; Programa principal
 000                     ;************************************
 000              start: 
 000  3C001              ENABLE INTERRUPT                              ; Habilito las interrupciones
 001                     ;************************************
 001                     ; Test de multiplicacion SIN signo:
 001                     ;************************************
 001                     ; Carga de registros de entrada
 001  000F0              LOAD multiplicando[s0], F0
 002  001B2              LOAD multiplicador[s1], B2
 003  00200              LOAD signo[s2], 00
 004                     ; Multiplico
 004  301B0              CALL multiply[1B0]
 005                     ; Verifico el resultado y enciendo un LED si fue satisfactorio
 005  00600              LOAD esperado_alto[s6], 00
 006  00700              LOAD esperado_bajo[s7], 00
 007  301B7              CALL verify[1B7]
 008  2C802              OUTPUT esperado_ok[s8], led_sin_signo[02]
 009                     ;************************************
 009                     ; Test de multiplicacion CON signo:
 009                     ;************************************
 009                     ; Carga de registros de entrada
 009  000F1              LOAD multiplicando[s0], F1
 00A  00150              LOAD multiplicador[s1], 50
 00B  002FF              LOAD signo[s2], FF
 00C                     ; Multiplico
 00C  301B0              CALL multiply[1B0]
 00D                     ; Verifico el resultado y enciendo un LED si fue satisfactorio
 00D  00600              LOAD esperado_alto[s6], 00
 00E  00700              LOAD esperado_bajo[s7], 00
 00F  301B7              CALL verify[1B7]
 010  2C803              OUTPUT esperado_ok[s8], led_con_signo[03]
 011                end: 
 011  34011              JUMP end[011]
 012                     ; y enciendo un LED si el resultado fue satisfactorio
 012                     ;************************************
 012                     ; Subrutina de multiplicacion
 012                     ;************************************
 1B0                     ADDRESS 1B0
 1B0           multiply: 
 1B0                     ; Escribo los operandos en los registros del multiplicador
 1B0  2C001              OUTPUT multiplicando[s0], n1[01]
 1B1  2C102              OUTPUT multiplicador[s1], n2[02]
 1B2  2C203              OUTPUT signo[s2], sign[03]
 1B3                     ; Espero el resultado de la multiplicacion
 1B3         mult_ready: 
 1B3  12501              TEST semaforo_mult[s5], 01                    ; Intento tomar el semaforo
 1B4  355B3              JUMP NZ, mult_ready[1B3]                      ; Si no puedo tomar el semaforo espero
 1B5  00500              LOAD semaforo_mult[s5], 00                    ; Tomo el semaforo
 1B6  2A000              RETURN
 1B7                     ;************************************
 1B7                     ; Subrutina de verificacion
 1B7                     ;************************************
 1B7             verify: 
 1B7                     ; Comparo el byte alto
 1B7  04304              INPUT resultado_alto[s3], rh[04]
 1B8  15360              COMPARE resultado_alto[s3], esperado_alto[s6]
 1B9  355BE              JUMP NZ, nok[1BE]
 1BA                     ; Comparo el byte bajo
 1BA  04404              INPUT resultado_bajo[s4], rh[04]
 1BB  15470              COMPARE resultado_bajo[s4], esperado_bajo[s7]
 1BC  355BE              JUMP NZ, nok[1BE]
 1BD                     ; Asigno el resultado de la comparacion
 1BD                 ok: 
 1BD  00801              LOAD esperado_ok[s8], 01
 1BE                nok: 
 1BE  00800              LOAD esperado_ok[s8], 00
 1BF  2A000              RETURN
 1C0                     ;************************************
 1C0                     ; Subrutina de interrupcion
 1C0                     ;************************************
 2B0                     ADDRESS 2B0
 2B0           int_call: 
 2B0  00501              LOAD semaforo_mult[s5], 01                    ; Doy un semaforo de multiplicacion finalizada
 2B1  38001              RETURNI ENABLE
 2B2                     ;************************************
 2B2                     ; Configurar vector de interrupcion
 2B2                     ;************************************
 3FF                     ADDRESS 3FF
 3FF  342B0              JUMP int_call[2B0]
